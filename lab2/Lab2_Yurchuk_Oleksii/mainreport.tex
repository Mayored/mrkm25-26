\section{Вступ}

У цій лабораторній я намагався зробити комплексний аналіз алгоритмів генерації псевдовипадкових чисел (PRNG), методів
тестування на простоту та методів генерації простих чисел, реалізованих у криптографічній бібліотеці OpenSSL для платформи
Windows. Основну увагу зосередив на часовій ефективності, зручності використання для генерації ключів асиметричної криптосистеми
та аналізу стабільності реалізацій OpenSSL~\cite{openssl_manual, viega2002network}.

\section{Генератори псевдовипадкових чисел в OpenSSL}

\subsection{RAND\_bytes Function}

\subsubsection{Description}
Функція \texttt{RAND\_bytes()} є основним інтерфейсом для генерації криптографічно захищених псевдовипадкових байтів
в OpenSSL. Вона використовує OpenSSL PRNG, який базується на поєднанні джерел ентропії та криптографічних
алгоритмів~\cite{openssl_manual, barker2015recommendation}.

\subsubsection{Algorithm}
OpenSSL використовує DRBG (Deterministic Random Bit Generator) на основі CTR-DRBG з AES-256 як зазначено в
NIST SP 800-90A~\cite{barker2015recommendation}. \\
Алгоритм є наступним:
\begin{itemize}
    \item Збирається ентропія з системних джерел (Windows CryptoAPI, hardware RNG якщо доступно)
    \item Seeds the DRBG за допомогою зібраної ентропії
    \item Генерує псевдовипадкові дані, використовуючи AES-CTR mode
    \item Періодично reseeds для забезпеченя і підтримки безпеки
\end{itemize}

\begin{algorithm}
    \caption{CTR-DRBG Generate Algorithm}
    \begin{algorithmic}[1]
        \Require Внутрішній стан $(Key, V, reseed\_counter)$
        \Require Кількість бітів для генерації $n$
        \Ensure Псевдовипадкові біти на $output$
        \If{$reseed\_counter > reseed\_interval$}
        \State Reseed DRBG
        \EndIf
        \State $temp \gets \emptyset$
        \While{$length(temp) < n$}
        \State $V \gets (V + 1) \mod 2^{blocklen}$
        \State $output\_block \gets AES\_Encrypt(Key, V)$
        \State $temp \gets temp \| output\_block$
        \EndWhile
        \State $output \gets$ leftmost $n$ bits of $temp$
        \State $reseed\_counter \gets reseed\_counter + 1$
        \State \Return $output$
    \end{algorithmic}
\end{algorithm}

\subsubsection{Function Signature}
\begin{minted}{c}
int RAND_bytes(unsigned char *buf, int num);
\end{minted}

\subsubsection{Input Parameters}
\begin{itemize}
    \item \texttt{buf}: Вказівник на буфер, де зберігатимуться випадкові байти
    \item \texttt{num}:  Кількість випадкових байтів, що будуть згенеровані (integer)
\end{itemize}

\subsubsection{Output Data}
\begin{itemize}
    \item Buffer \texttt{buf} is filled with \texttt{num} cryptographically secure random bytes
\end{itemize}

\subsubsection{Return Codes}
\begin{itemize}
    \item \textbf{1}: Success -- випадкові байти згенеровані успішно
    \item \textbf{0}: Failure -- PRNG seeded з недостатньою ентропією
    \item \textbf{-1}: Функція не підтримується (рідко)
\end{itemize}

\subsubsection{Приклад використання}
\begin{minted}{c}
#include <openssl/rand.h>
#include <stdio.h>

int main() {
    unsigned char buffer[32];
    
    if (RAND_bytes(buffer, 32) != 1) {
        fprintf(stderr, "RAND_bytes failed\n");
        return 1;
    }
    
    printf("Generated random bytes successfully\n");
    return 0;
}
\end{minted}

\subsection{RAND\_priv\_bytes Function}

\subsubsection{Description}
Подібна до \texttt{RAND\_bytes()}, але спеціально розроблена для генерації матеріалів приватного ключа. Використовує 
окремий екземпляр DRBG для підвищення рівня безпеки~\cite{openssl_manual}.

\subsubsection{Algorithm}
Використовує той самий алгоритм (CTR-DRBG) що й \texttt{RAND\_bytes()} але підтримує окремий стан, щоб ізолювати генерацію
приватного ключа від інших операцій генерації випадкових чисел.

\subsubsection{Function Signature}
\begin{minted}{c}
int RAND_priv_bytes(unsigned char *buf, int num);
\end{minted}

\subsubsection{Input/Output/Return Codes}
Ідентично до \texttt{RAND\_bytes()}.

\subsection{RAND\_seed Function}

\subsubsection{Description}
Вручну додає ентропію до початкового значення PRNG seed. Є корисною, коли доступні додаткові джерела 
ентропії~\cite{eastlake2005randomness}.

\subsubsection{Function Signature}
\begin{minted}{c}
void RAND_seed(const void *buf, int num);
\end{minted}

\subsubsection{Input Parameters}
\begin{itemize}
    \item \texttt{buf}: Вказівник на буфер, що містить дані ентропії
    \item \texttt{num}: Кількість байтів ентропії
\end{itemize}

\subsubsection{Return Value}
Function returns void (no return code).

\subsection{RAND\_status Function}

\subsubsection{Description}
Перевіряє, чи PRNG було seeded з достатньою ентропією~\cite{openssl_manual}.

\subsubsection{Function Signature}
\begin{minted}{c}
int RAND_status(void);
\end{minted}

\subsubsection{Return Codes}
\begin{itemize}
    \item \textbf{1}: PRNG seeded з достатньою ентропією
    \item \textbf{0}: PRNG seeded недостатньо
\end{itemize}

\section{Функції перевірки на простоту}

\subsection{BN\_is\_prime\_ex Function}

\subsubsection{Description}
Перевіряє, чи є BIGNUM ймовірно простим числом, використовуючи Miller-Rabin primality test~\cite{rabin1980probabilistic, menezes1996handbook}.

\subsubsection{Algorithm}
Тест Міллера-Рабіна є імовірнісним алгоритмом перевірки на простоту~\cite{miller1976riemann}:

\begin{algorithm}
    \caption{Miller-Rabin Primality Test}
    \begin{algorithmic}[1]
        \Require Odd integer $n > 2$, number of rounds $k$
        \Ensure \textbf{composite} or \textbf{probably prime}
        \State Write $n-1$ as $2^r \cdot d$ where $d$ is odd
        \For{$i = 1$ to $k$}
        \State Choose random $a \in [2, n-2]$
        \State $x \gets a^d \bmod n$
        \If{$x = 1$ or $x = n-1$}
        \State \textbf{continue}
        \EndIf
        \For{$j = 1$ to $r-1$}
        \State $x \gets x^2 \bmod n$
        \If{$x = n-1$}
        \State \textbf{continue} to outer loop
        \EndIf
        \EndFor
        \State \Return \textbf{composite}
        \EndFor
        \State \Return \textbf{probably prime}
    \end{algorithmic}
\end{algorithm}

Імовірність того, що складене число пройде $k$ раундів, становить не більше ніж $4^{-k}$~\cite{rabin1980probabilistic}.

\subsubsection{Function Signature}
\begin{minted}{c}
int BN_is_prime_ex(const BIGNUM *p, int nchecks, 
                   BN_CTX *ctx, BN_GENCB *cb);
\end{minted}

\subsubsection{Input Parameters}
\begin{itemize}
    \item \texttt{p}: BIGNUM, яке тестуватиметься на простоту
    \item \texttt{nchecks}: Кількість ітерацій для тесту Міллера-Рабіна (0 для автоматичного вибору)
    \item \texttt{ctx}: BN\_CTX Деяка структура для тимчасових зміних (can be NULL)
    \item \texttt{cb}: Callback для моніторингу прогресу (can be NULL)
\end{itemize}

\subsubsection{Output}
Повертає результат of primality test.

\subsubsection{Return Codes}
\begin{itemize}
    \item \textbf{1}: Число ймовірно просте
    \item \textbf{0}: Число точно складене
    \item \textbf{-1}: Сталася помилка
\end{itemize}

\subsection{BN\_is\_prime\_fasttest\_ex Function}

\subsubsection{Description}
Покращена версія функції \texttt{BN\_is\_prime\_ex} яка виконує пробне ділення перед Miller-Rabin testing~\cite{crandall2005prime}.

\subsubsection{Algorithm}
\begin{enumerate}
    \item Trial division: Перевірка подільності на невеликі прості числа (up to 3317)
    \item Якщо пробне ділення є успішним, виконується власне тест Міллера-Рабіна
\end{enumerate}

Це значно прискорює виявлення складених чисел.

\subsubsection{Function Signature}
\begin{minted}{c}
int BN_is_prime_fasttest_ex(const BIGNUM *p, int nchecks,
                             BN_CTX *ctx, int do_trial_division,
                             BN_GENCB *cb);
\end{minted}

\subsubsection{Input Parameters}
Такі саме як і в \texttt{BN\_is\_prime\_ex}, додатково:
\begin{itemize}
    \item \texttt{do\_trial\_division}: Якщо 1, виконати спершу пробне ділення; якщо 0 -- пропустити
\end{itemize}

\subsubsection{Return Codes}
Такі самі, як і у \texttt{BN\_is\_prime\_ex}.

\section{Генерування простих чисел}

\subsection{BN\_generate\_prime\_ex Function}

\subsubsection{Description}
Генерує криптографічно надійне псевдовипадкове просте число~\cite{menezes1996handbook}.

\newpage %FORCED ...
\subsubsection{Algorithm}
\begin{algorithm}
    \caption{Prime Number Generation}
    \begin{algorithmic}[1]
        \Require Bit length $bits$, safety flag $safe$
        \Ensure Prime number $p$
        \State Generate random odd number $p$ of $bits$ length
        \State Set MSB and LSB to 1
        \Repeat
        \State Perform trial division against small primes
        \If{divisible by small prime}
        \State $p \gets p + 2$
        \State \textbf{continue}
        \EndIf
        \State Apply Miller-Rabin test to $p$
        \If{$p$ is composite}
        \State $p \gets p + 2$
        \Else
        \If{$safe$ is true}
        \State Check if $(p-1)/2$ is also prime
        \If{$(p-1)/2$ is not prime}
        \State $p \gets p + 2$
        \State \textbf{continue}
        \EndIf
        \EndIf
        \State \Return $p$
        \EndIf
        \Until{prime found}
    \end{algorithmic}
\end{algorithm}

Для "безпечних"{} простих чисел (when \texttt{add} parameter is used) додаткові перевірки гарантують, що $(p-1)/2$ 
також є простим числом ~\cite{schneier2015applied}.

\subsubsection{Function Signature}
\begin{minted}{c}
int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe,
                         const BIGNUM *add, const BIGNUM *rem,
                         BN_GENCB *cb);
\end{minted}

\subsubsection{Input Parameters}
\begin{itemize}
    \item \texttt{ret}: BIGNUM structure для зберігання згенерованого простого числа
    \item \texttt{bits}: Бітова довжина простих чисел, що генеруються
    \item \texttt{safe}: Якщо 1, генерується "безпечне"{} просте число, де $(p-1)/2$ також просте
    \item \texttt{add}: Якшо not NULL, просте число повинно задовольняти умову: $p \bmod add = rem$
    \item \texttt{rem}: Значення залишку (used with \texttt{add})
    \item \texttt{cb}: Callback для моніторингу прогресу
\end{itemize}

\subsubsection{Output Data}
BIGNUM \texttt{ret}  містить згенероване просте число.

\subsubsection{Return Codes}
\begin{itemize}
    \item \textbf{1}: Success -- просте число згенеровано
    \item \textbf{0}: Failure -- сталася помилка
\end{itemize}

\subsubsection{Приклад використання}
\begin{minted}{c}
#include <openssl/bn.h>

int main() {
    BIGNUM *prime = BN_new();
    
    if (BN_generate_prime_ex(prime, 2048, 0, NULL, NULL, NULL) != 1) {
        fprintf(stderr, "Prime generation failed\n");
        BN_free(prime);
        return 1;
    }
    
    printf("Generated 2048-bit prime successfully\n");
    BN_free(prime);
    return 0;
}
\end{minted} 

\section{Генерація RSA Key}

\subsection{RSA\_generate\_key\_ex Function}

\subsubsection{Description}
Генерує пару RSA keys pair із заданим розміром модуля та публічним показником~\cite{rivest1978method, menezes1996handbook}.

\newpage
\subsubsection{Algorithm}
\begin{algorithm}
    \caption{RSA Key Pair Generation}
    \begin{algorithmic}[1]
        \Require Bit length $bits$, public exponent $e$
        \Ensure RSA key pair $(n, e, d, p, q, dP, dQ, qInv)$
        \State Generate random prime $p$ of $bits/2$ length
        \State Generate random prime $q$ of $bits/2$ length, $q \neq p$
        \State Compute modulus $n \gets p \times q$
        \State Compute Euler's totient $\phi(n) \gets (p-1)(q-1)$
        \State Verify $\gcd(e, \phi(n)) = 1$
        \State Compute private exponent $d \gets e^{-1} \bmod \phi(n)$
        \State Compute CRT parameter $dP \gets d \bmod (p-1)$
        \State Compute CRT parameter $dQ \gets d \bmod (q-1)$
        \State Compute CRT parameter $qInv \gets q^{-1} \bmod p$
        \State \Return $(n, e, d, p, q, dP, dQ, qInv)$
    \end{algorithmic}
\end{algorithm}

\subsubsection{Function Signature}
\begin{minted}{c}
int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e,
                        BN_GENCB *cb);
\end{minted}

\subsubsection{Input Parameters}
\begin{itemize}
    \item \texttt{rsa}: RSA structure для зберігання згенерованого ключа
    \item \texttt{bits}: Довжина модуля в бітах (зазвичай це 2048, 3072, або 4096)
    \item \texttt{e}: Публічна експонента BIGNUM (часто дорівнює 65537 = $2^{16}+1$)
    \item \texttt{cb}: Callback для моніторингу прогресу
\end{itemize}

\subsubsection{Output Data}
Структура RSA задається наступним чином:
\begin{itemize}
    \item Public key: $(n, e)$
    \item Private key: $(n, d)$ і додатково параметри $(p, q, dP, dQ, qInv)$
\end{itemize}

\subsubsection{Return Codes}
\begin{itemize}
    \item \textbf{1}: Success -- пара ключів згенерована
    \item \textbf{0}: Failure --  сталася помилка
\end{itemize}

\subsubsection{Приклад використання}
\begin{minted}{c}
#include <openssl/rsa.h>
#include <openssl/bn.h>

int main() {
    RSA *rsa = RSA_new();
    BIGNUM *e = BN_new();
    BN_set_word(e, RSA_F4); // e = 65537
    
    if (RSA_generate_key_ex(rsa, 2048, e, NULL) != 1) {
        fprintf(stderr, "RSA key generation failed\n");
        RSA_free(rsa);
        BN_free(e);
        return 1;
    }
    
    printf("Generated 2048-bit RSA key pair successfully\n");
    
    // Cleanup
    RSA_free(rsa);
    BN_free(e);
    return 0;
}
\end{minted}

\section{Генерація DSA Key}

\subsection{DSA\_generate\_parameters\_ex Function}

\subsubsection{Description}
Генерує DSA доменні параметри $(p, q, g)$ згідно до FIPS 186-4~\cite{fips186}.

\subsubsection{Algorithm}
Використовує алгоритм, визначений в FIPS 186-4~\cite{fips186}:
\begin{enumerate}
    \item Згенерувати просте число $q$ із заданою бітовою довжиною (зазвичай 160, 224, або 256 бітів)
    \item Згенерувати просте число $p$ таке, що $q$ ділиить $(p-1)$ і $p$ має необіхдну бітову довжину
    \item Знайти генератор $g$ порядку $q$ в полі $\mathbb{Z}_p^*$: вибрати $h \in [2, p-2]$ і обчислювати $g = h^{(p-1)/q} \bmod p$, доки це $g > 1$
\end{enumerate}

\subsubsection{Function Signature}
\begin{minted}{c}
int DSA_generate_parameters_ex(DSA *dsa, int bits,
                               const unsigned char *seed,
                               int seed_len, int *counter_ret,
                               unsigned long *h_ret,
                               BN_GENCB *cb);
\end{minted}

\subsubsection{Input Parameters}
\begin{itemize}
    \item \texttt{dsa}: DSA structure для зберігання параметрів
    \item \texttt{bits}: Бітова довжина числа $p$ (1024, 2048, або 3072)
    \item \texttt{seed}: Опціональний seed для генерації  (can be NULL)
    \item \texttt{seed\_len}: Довжина of seed (в бітах)
    \item \texttt{counter\_ret}: Вказівник для зберігання лічильника генерації (can be NULL)
    \item \texttt{h\_ret}: Вказівник для зберігання $h$, використаного при генерації (can be NULL)
    \item \texttt{cb}: Callback для моніторингу прогресу
\end{itemize}

\subsubsection{Return Codes}
\begin{itemize}
    \item \textbf{1}: Success
    \item \textbf{0}: Failure
\end{itemize}

\subsection{DSA\_generate\_key Function}

\subsubsection{Description}
Генерує DSA public/private key pair використовуючи існуючі доменні параметри~\cite{fips186}.

\subsubsection{Algorithm}
\begin{enumerate}
    \item Згенерувати випадковий private key: $x \in [1, q-1]$
    \item Згенерувати public key: $y = g^x \bmod p$
\end{enumerate}

\subsubsection{Function Signature}
\begin{minted}{c}
int DSA_generate_key(DSA *dsa);
\end{minted}

\subsubsection{Input Parameters}
\begin{itemize}
    \item \texttt{dsa}: DSA structure, що містить доменні параметри
\end{itemize}

\subsubsection{Output Data}
DSA structure, що заповнена приватним ключем $x$ та публічним ключем $y$.

\subsubsection{Return Codes}
\begin{itemize}
    \item \textbf{1}: Success
    \item \textbf{0}: Failure
\end{itemize}

\section{Генерація Elliptic Curve Key}

\subsection{EC\_KEY\_generate\_key Function}

\subsubsection{Description}
Генерує пару ключів еліптичної кривої для обраної кривої~\cite{hankerson2006guide, koblitz1987elliptic}.

\subsubsection{Algorithm}
\begin{enumerate}
    \item Генерується випадковий private key: $d \in [1, n-1]$ де $n$ -- порядок кривої
    \item Обчислюється точка публічного ключа, така що: $Q = d \cdot G$ де $G$ -- генеративна точка, з використанням 
    операції множення точок еліптичної кривої
\end{enumerate}

Безпека криптографії з еліптичними кривими базується на проблемі взяття дискретного логарифму на еліптичній кривій (ECDLP)~\cite{miller1986use}.

\subsubsection{Function Signature}
\begin{minted}{c}
int EC_KEY_generate_key(EC_KEY *key);
\end{minted}

\subsubsection{Input Parameters}
\begin{itemize}
    \item \texttt{key}: EC\_KEY structure з набором параметрів кривої
\end{itemize}

\subsubsection{Output Data}
EC\_KEY structure заповнена за допомогою private key scalar і public key point.

\subsubsection{Return Codes}
\begin{itemize}
    \item \textbf{1}: Success
    \item \textbf{0}: Failure
\end{itemize}

\subsubsection{Приклад використання}
\begin{minted}{c}
#include <openssl/ec.h>
#include <openssl/obj_mac.h>

int main() {
    // Create EC_KEY structure for secp256k1 curve
    EC_KEY *key = EC_KEY_new_by_curve_name(NID_secp256k1);
    
    if (key == NULL) {
        fprintf(stderr, "Failed to create EC_KEY\n");
        return 1;
    }
    
    if (EC_KEY_generate_key(key) != 1) {
        fprintf(stderr, "EC key generation failed\n");
        EC_KEY_free(key);
        return 1;
    }
    
    printf("Generated EC key pair successfully\n");
    
    // Cleanup
    EC_KEY_free(key);
    return 0;
}
\end{minted}

\section{Аналіз часової ефективності}

\subsection{Продуктивність PRNG}
\texttt{RAND\_bytes()} в операційній системі Windows використовує CTR-DRBG з AES-256~\cite{barker2015recommendation}:
\begin{itemize}
    \item Типова пропускна здатність: 200--500 MB/s на сучасних CPUs
    \item Підтримка інструкцій AES-NI значно покращує продуктивність (up to 2--3 GB/s)
    \item Накладні витрати на reseeding: приблизно 1--2 ms на кожні $2^{48}$ згенерованих байтів
    \item  Незначний вплив на продуктивність для типових операцій генерації ключів
\end{itemize}

\subsection{Продуктивність тесту на простоту}
Для алгоритму Міллера-Рабіна з пробним діленням (\texttt{BN\_is\_prime\_fasttest\_ex})~\cite{crandall2005prime}:
\begin{itemize}
    \item Числа довжини 1024-bit: 1--5 ms (зазвичай в середньому: 2 ms)
    \item Числа довжини 2048-bit: 10--50 ms (зазвичай в середньому: 25 ms)
    \item Числа довжини 4096-bit: 100--500 ms (зазвичай в середньому: 250 ms)
\end{itemize}

Продуктивність сильно залежить від заданої кількості ітерацій і можливостей процесора. Пробне ділення виключає 
приблизно 80--90\% складених кандидатів перед самим тестуванням Міллера-Рабіна.

\subsection{Продуктивність генерації простих чисел}
Середній час для \texttt{BN\_generate\_prime\_ex}~\cite{menezes1996handbook}:
\begin{itemize}
    \item 1024-bit просте число: 50--200 ms (зазвичай в середньому: 100 ms)
    \item 2048-bit просте число: 500--2000 ms (зазвичай в середньому: 1000 ms)
    \item 4096-bit просте число: 5--20 seconds (зазвичай в середньому: 10 seconds)
\end{itemize}

Генерація "безпечних"{} простих чисел займає значно більше часу (в 10--100 разів) залежно до вимог на $p$ та 
$(p-1)/2$. Вони обидва мають бути простими.

\subsection{Продуктивність генерації RSA key}
Продуктивність \texttt{RSA\_generate\_key\_ex}~\cite{rivest1978method}:
\begin{itemize}
    \item Ключ довжини 2048-bit: 100--500 ms (зазвичай в середньому: 250 ms)
    \item Ключ довжини 3072-bit: 500--2000 ms (зазвичай в середньому: 1000 ms)
    \item Ключ довжини 4096-bit: 2--10 seconds (зазвичай в середньому: 5 seconds)
\end{itemize}

Більше 90\% часу витрачається на генерацію простих $p$ та $q$. Знаходження оберененого за модулем для приватної експоненти 
$d$ є відносно швидкою операцією.

\subsection{Продуктивність генерації DSA Key}
\begin{itemize}
    \item Генерація параметрів (1024-bit $p$, 160-bit $q$): 1--5 seconds
    \item Генерація параметрів (2048-bit $p$, 256-bit $q$): 5--30 seconds
    \item Генерація пари (за заданими параметрами): <10 ms
\end{itemize}

\subsection{Продуктивність генерації ECC Key}
\begin{itemize}
    \item secp256r1 (NIST P-256): 1--3 ms
    \item secp384r1 (NIST P-384): 3--8 ms
    \item secp521r1 (NIST P-521): 8--20 ms
\end{itemize}

Генерація ECC key є значно швидшою за RSA для порівнюваних рівнів безпеки~\cite{hankerson2006guide}.

\section{Опис стабільності та безпеки}

\subsection{Стабільність PRNG}
Реалізація OpenSSL's в PRNG вважається стабільною та безпечною, коли~\cite{viega2002network}:
\begin{itemize}
    \item Операційна система забезпечує достатні джерела ентропії
    \item \texttt{RAND\_status()} повернув 1 перед генерацією ключів
    \item Не було внесено змін до внутрішнього стану PRNG
    \item Бібліотека скомпільована з належними механізмами збору ентропії
\end{itemize}

\subsection{Windows Platform}
У Windows OpenSSL використовується~\cite{microsoft_crypto}:
\begin{itemize}
    \item \texttt{CryptGenRandom} API (Windows XP--10) or \texttt{BCryptGenRandom} (Windows 10+) для збору ентропії
    \item Інструкції RDRAND/RDSEED CPU якщо доступні модифікації (Intel Ivy Bridge+, AMD Ryzen+)
    \item Лічильники продуктивності системи як додаткове джерело ентропії
    \item Ідентифікатори(IDs) процесів і потоків, часові мітки з високою роздільною здатністю
\end{itemize}

Джерела ентропії Windows вважаються криптографічно безпечними для цілей генерації ключів~\cite{gutmann1998software}.

\subsection{Найкращі поради-практики з безпеки}
\begin{enumerate}
    \item \textbf{Розмір ключів}: Використовуйте мінімум 2048-bit RSA ключ (еквівалентний до 112-bit рівня безпеки), 
        256-bit ECC (еквівалентний до 128-bit рівня безпеки)~\cite{barker2020recommendation}
    \item \textbf{Використання PRNG}: Завжди використовуйте \texttt{RAND\_priv\_bytes()} для генерації даних для private key
    \item \textbf{Обробка помилок}: Перевіряйте Return Codes для всіх функцій OpenSSL; Не продовжуйте, якщо виникають помилки
    \item \textbf{Перевірка ентропії}: Підтвердіть PRNG статус перед генерацією ключа: \texttt{RAND\_status() == 1}
    \item \textbf{Безпека пам'яті}: Видаляйте конфіденційні матеріали ключів з пам'яті після використання за допомогою 
        функції \texttt{OPENSSL\_cleanse()}
    \item \textbf{Оновлення бібліотеки}: Keep OpenSSL up to date для отримування найновіших патчів безпеки
\end{enumerate}

\subsection{Поширені імплементаційні проблеми}
\begin{itemize}
    \item \textbf{Недостатня ентропія}: У віртуальних або вбудованих системах джерела ентропії можуть бути обмеженими
    \item \textbf{Безпека розгалуження}: Після \texttt{fork()}, дочірні процеси повинні перезапустити PRNG, щоб уникнути 
        дублювання випадкових послідовностей
    \item \textbf{Безпека потоків}: OpenSSL 1.1.0+ є безпечним для потоків за замовчуванням; попередні версії 
        вимагають явного блокування
    \item \textbf{Memory Leaks}: Завжди звільняйте виділені структури \texttt{BN\_free()}, \texttt{RSA\_free()}, \texttt{EC\_KEY\_free()}
\end{itemize}

\section{Порівняльний аналіз}

\subsection{Придатність алгоритму для генерації ключів}

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Algorithm} & \textbf{Key Gen Time} & \textbf{Security/Bit} & \textbf{Suitability} \\
        \hline
        RSA-2048           & ~250 ms               & Moderate              & High                 \\
        RSA-3072           & ~1000 ms              & High                  & High                 \\
        RSA-4096           & ~5000 ms              & Very High             & Medium               \\
        \hline
        DSA-2048           & ~10000 ms             & High                  & Medium               \\
        DSA-3072           & ~20000 ms             & Very High             & Medium               \\
        \hline
        ECC-256            & ~2 ms                 & High                  & Very High            \\
        ECC-384            & ~5 ms                 & Very High             & Very High            \\
        ECC-521            & ~15 ms                & Extreme               & High                 \\
        \hline
    \end{tabular}
    \caption{Порівняння алгоритмів генерації ключів}
\end{table}

Для сучасних додатків ECC забезпечує найкращий баланс між безпекою та продуктивністю ~\cite{hankerson2006guide}. 
В той час як RSA залишається широко використовуваним завдяки сумісності та налагодженій інфраструктурі~\cite{schneier2015applied}.

\subsection{Порівняння алгоритмів PRNG}

Реалізація в OpenSSL's CTR-DRBG має переваги над альтернативними PRNGs, оскільки:
\begin{itemize}
    \item \textbf{Безпека}: Базується на алгоритмі затвердженому в NIST з формальним аналізом безпеки
    \item \textbf{Продуктивність}: Апаратне прискорення AES забезпечує чудову пропускну здатність
    \item \textbf{Стійкість до передбачуваності:}: Пряма пряма секретність завдяки періодичному reseeding
    \item \textbf{Стійкість до зворотного відстеження}: Неможливість виведення попередніх результатів з поточного стану
    \item \textbf{Стандартизація}: Реалізація, що відповідає стандарту FIPS 140-2
\end{itemize}

\section{Приклади реалізацій}

\subsection{Повне генерування ключів RSA з обробкою помилок}

\begin{minted}{c}
#include <openssl/rsa.h>
#include <openssl/bn.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <stdio.h>

int generate_rsa_keypair(const char *public_key_file, 
                        const char *private_key_file) {
    RSA *rsa = NULL;
    BIGNUM *e = NULL;
    FILE *fp = NULL;
    int ret = 0;
    
    // Check PRNG status
    if (RAND_status() != 1) {
        fprintf(stderr, "PRNG not sufficiently seeded\n");
        return 0;
    }
    
    // Initialize structures
    rsa = RSA_new();
    e = BN_new();
    
    if (!rsa || !e) {
        fprintf(stderr, "Memory allocation failed\n");
        goto cleanup;
    }
    
    // Set public exponent to 65537
    if (BN_set_word(e, RSA_F4) != 1) {
        fprintf(stderr, "Failed to set public exponent\n");
        goto cleanup;
    }
    
    // Generate 2048-bit RSA key pair
    printf("Generating 2048-bit RSA key pair...\n");
    if (RSA_generate_key_ex(rsa, 2048, e, NULL) != 1) {
        fprintf(stderr, "RSA key generation failed\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }
    
    // Save public key
    fp = fopen(public_key_file, "wb");
    if (!fp) {
        fprintf(stderr, "Cannot open public key file\n");
        goto cleanup;
    }
    
    if (PEM_write_RSAPublicKey(fp, rsa) != 1) {
        fprintf(stderr, "Failed to write public key\n");
        goto cleanup;
    }
    fclose(fp);
    fp = NULL;
    
    // Save private key
    fp = fopen(private_key_file, "wb");
    if (!fp) {
        fprintf(stderr, "Cannot open private key file\n");
        goto cleanup;
    }
    
    if (PEM_write_RSAPrivateKey(fp, rsa, NULL, NULL, 0, 
                                NULL, NULL) != 1) {
        fprintf(stderr, "Failed to write private key\n");
        goto cleanup;
    }
    
    printf("Key pair generated successfully\n");
    ret = 1;
    
cleanup:
    if (fp) fclose(fp);
    if (rsa) RSA_free(rsa);
    if (e) BN_free(e);
    return ret;
}

int main() {
    return generate_rsa_keypair("public.pem", "private.pem") ? 0 : 1;
}
\end{minted}

\subsection{Генерація ключів ECC з декількома еліптичними кривими}

\begin{minted}{c}
#include <openssl/ec.h>
#include <openssl/obj_mac.h>
#include <openssl/pem.h>
#include <stdio.h>

typedef struct {
    int nid;
    const char *name;
} curve_info_t;

int generate_ec_key(int curve_nid, const char *filename) {
    EC_KEY *key = NULL;
    FILE *fp = NULL;
    int ret = 0;
    
    // Create EC_KEY for specified curve
    key = EC_KEY_new_by_curve_name(curve_nid);
    if (!key) {
        fprintf(stderr, "Failed to create EC_KEY\n");
        return 0;
    }
    
    // Generate key pair
    if (EC_KEY_generate_key(key) != 1) {
        fprintf(stderr, "EC key generation failed\n");
        EC_KEY_free(key);
        return 0;
    }
    
    // Verify key
    if (EC_KEY_check_key(key) != 1) {
        fprintf(stderr, "EC key verification failed\n");
        EC_KEY_free(key);
        return 0;
    }
    
    // Save to file
    fp = fopen(filename, "wb");
    if (!fp) {
        fprintf(stderr, "Cannot open file\n");
        EC_KEY_free(key);
        return 0;
    }
    
    if (PEM_write_ECPrivateKey(fp, key, NULL, NULL, 0, 
                               NULL, NULL) == 1) {
        ret = 1;
    }
    
    fclose(fp);
    EC_KEY_free(key);
    return ret;
}

int main() {
    curve_info_t curves[] = {
        {NID_secp256k1, "secp256k1"},
        {NID_X9_62_prime256v1, "secp256r1"},
        {NID_secp384r1, "secp384r1"},
        {NID_secp521r1, "secp521r1"}
    };
    
    for (int i = 0; i < 4; i++) {
        char filename[64];
        snprintf(filename, sizeof(filename), "ec_%s.pem", 
                curves[i].name);
        
        printf("Generating key for curve %s...\n", curves[i].name);
        if (generate_ec_key(curves[i].nid, filename)) {
            printf("Success: %s\n", filename);
        } else {
            printf("Failed: %s\n", curves[i].name);
        }
    }
    
    return 0;
}
\end{minted}

\subsection{Генерація простих чисел зі зворотнім викликом прогресу}

\begin{minted}{c}
#include <openssl/bn.h>
#include <stdio.h>

int prime_callback(int p, int n, BN_GENCB *cb) {
    char c = '*';
    
    if (p == 0) c = '.';      // Starting search
    if (p == 1) c = '+';      // Found candidate
    if (p == 2) c = '*';      // Passed primality test
    if (p == 3) c = '\n';     // Generation complete
    
    putchar(c);
    fflush(stdout);
    return 1;
}

int main() {
    BIGNUM *prime = BN_new();
    BN_GENCB *cb = BN_GENCB_new();
    
    if (!prime || !cb) {
        fprintf(stderr, "Allocation failed\n");
        return 1;
    }
    
    // Set up callback
    BN_GENCB_set(cb, prime_callback, NULL);
    
    printf("Generating 2048-bit prime number:\n");
    
    if (BN_generate_prime_ex(prime, 2048, 0, NULL, NULL, cb) != 1) {
        fprintf(stderr, "Prime generation failed\n");
        BN_free(prime);
        BN_GENCB_free(cb);
        return 1;
    }
    
    // Print the prime in hexadecimal
    char *prime_hex = BN_bn2hex(prime);
    printf("\nGenerated prime:\n%s\n", prime_hex);
    
    // Cleanup
    OPENSSL_free(prime_hex);
    BN_free(prime);
    BN_GENCB_free(cb);
    
    return 0;
}
\end{minted}

\section{Benchmarking Results}

\subsection{Тестове середовище}
Тести проводилися на:
\begin{itemize}
    \item \textbf{OS}: Windows 10 Professional (64-bit)
    \item \textbf{CPU}: Intel Core i7-1065G @ 1.5 GHz
    \item \textbf{RAM}: 16 GB DDR4
    \item \textbf{OpenSSL Version}: 3.3.0
    \item \textbf{Compiler}: Microsoft Visual Studio 2019
\end{itemize}

\subsection{Тести на пропускну здатність PRNG}

Пропускна здатність збільшується із розміром буфера завдяки зменшенню накладних витрат на виклик функції та 
кращому використанню кешу процесора:

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|r|r|}
        \hline
        \textbf{Buffer Size} & \textbf{Throughput (MB/s)} & \textbf{Latency} \\
        \hline
        16 bytes             & 45.2                       & 0.35 μs          \\
        256 bytes            & 312.5                      & 0.82 μs          \\
        4 KB                 & 1,024.0                    & 3.91 μs          \\
        64 KB                & 2,457.6                    & 26.05 μs         \\
        1 MB                 & 3,145.7                    & 327.68 μs        \\
        \hline
    \end{tabular}
    \caption{Пропускна здатність RAND\_bytes}
\end{table}

\subsection{Продуктивність тестування на простоту}

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|r|r|r|}
        \hline
        \textbf{Bit Length} & \textbf{No Trial Div.} & \textbf{With Trial Div.} & \textbf{Speedup} \\
        \hline
        512 bits            & 0.8 ms                 & 0.3 ms                   & 2.67×            \\
        1024 bits           & 3.2 ms                 & 1.8 ms                   & 1.78×            \\
        2048 bits           & 28.5 ms                & 24.1 ms                  & 1.18×            \\
        4096 bits           & 312.7 ms               & 286.3 ms                 & 1.09×            \\
        \hline
    \end{tabular}
    \caption{Середній час тесту (Міллера-Рабіна)}
\end{table}

Пробне ділення забезпечує значне прискорення виконання для менших чисел, але зменшує ефективність для більших 
значень.

\subsection{Тести генерації ключів}

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|r|r|r|}
        \hline
        \textbf{Algorithm} & \textbf{Min (ms)} & \textbf{Avg (ms)} & \textbf{Max (ms)} \\
        \hline
        RSA-2048           & 187               & 243               & 421               \\
        RSA-3072           & 724               & 981               & 1,653             \\
        RSA-4096           & 3,156             & 4,872             & 8,234             \\
        \hline
        ECC-256            & 1.2               & 1.8               & 3.4               \\
        ECC-384            & 3.7               & 5.2               & 8.9               \\
        ECC-521            & 11.3              & 15.7              & 24.6              \\
        \hline
        DSA-2048           & 8,234             & 11,457            & 19,821            \\
        \hline
    \end{tabular}
    \caption{Час генерації ключів (100 ітерацій)}
\end{table}

Висока варіативність часу генерації RSA та DSA пояснюється ймовірнісним характером пошуку простих чисел.

\section{Conclusion}

Бібліотека OpenSSL надає надійні, добре перевірені реалізації алгоритмів PRNG, методів перевірки простоти та 
функцій генерації ключів, придатних для виробничих криптографічних додатків. Ключові висновки:
\subsection{Key Findings}

\begin{enumerate}
    \item \textbf{Якість PRNG}: Реалізація CTR-DRBG з AES-256 забезпечує криптографічно безпечні випадкові числа 
        з чудовою пропускною здатністю (>3 ГБ/с з AES-NI) і відповідає вимогам NIST SP 800-90A~\cite{barker2015recommendation}.
    \item \textbf{Ефективність перевірки на простоту}: Поєднання пробного ділення та тестування Міллера-Рабіна забезпечує
        оптимальну продуктивність, швидко усуваючи більшість складених чисел, зберігаючи при цьому високу впевненість у 
        простоті~\cite{crandall2005prime}.
    \item \textbf{Придатність алгоритму}: Для нових реалізацій ECC пропонує найкраще співвідношення продуктивності та безпеки, 
        з генерацією ключів, що в 100--500 разів швидша, ніж ключі RSA з еквівалентною безпекою~\cite{hankerson2006guide}.
    \item \textbf{Стабільність платформи}: OpenSSL на Windows демонструє стабільну продуктивність при правильній конфігурації з
        джерелами системної ентропії (CryptGenRandom/BCryptGenRandom).
    \item \textbf{Стадія реалізації}: Всі протестовані функції демонструють стабільну поведінку та належне оброблення помилок, а також 
        вичерпну документацію, що робить їх придатними для генерації ключів асиметричної криптосистеми.
\end{enumerate}

\subsection{Рекомендації для практичного застосування}

\begin{itemize}
    \item Використовуйте \textbf{ECC-256 or ECC-384} для нових додатків, що вимагають оптимальної продуктивності
    \item Використовуйте \textbf{RSA-2048 or RSA-3072} коли потрібна сумісність з існуючою інфраструктурою
    \item Завжди обов'язково перевіряйте стан ініціалізації PRNG перед генерацією ключів
    \item Впровадьте комплексну обробку помилок для всіх викликів функцій OpenSSL
    \item Розглядайте генерування "безпечних"{} простих чисел тільки тоді, коли це конкретно вимагається протоколом 
        (через витрати на продуктивність).
    \item Використовуйте \texttt{RAND\_priv\_bytes()} замість \texttt{RAND\_bytes()} для складових приватного ключа
    \item Вмикайте інструкцію AES-NI для CPU задля оптимальної продуктивності алгоритму генерації PRNG
\end{itemize}

\subsection{Напрямки потенційних майбутніх досліджень}

Подальші дослідження можуть бути спрямовані на:
\begin{itemize}
    \item Реалізація постквантової криптографії в OpenSSL
    \item Аналіз продуктивності інтеграційного hardware security module (HSM)
    \item Порівняльний аналіз з альтернативними криптографічними бібліотеками
    \item Аналіз показників енергоефективності для вбудованих і мобільних платформ
    \item Стікість до атак по бічних каналах (side-channel attack) у реалізаціях генерації ключів
\end{itemize}

Бібліотека OpenSSL продовжує розвиватися, а поточна розробка зосереджена на постквантових алгоритмах, покращенні 
продуктивності та посиленні функцій безпеки для сучасних криптографічних вимог.

\newpage
\selectlanguage{english}
\printbibliography

\newpage
\appendix

\section{Compilation Instructions}

Для компіляції прикладних програм використовуються такі команди:

\subsection{Windows with MSVC}
\begin{minted}{bash}
cl /I"C:\OpenSSL\include" example.c /link 
   /LIBPATH:"C:\OpenSSL\lib" libcrypto.lib
\end{minted}

\subsection{Windows with MinGW}
\begin{minted}{bash}
gcc -o example example.c -I/c/OpenSSL/include 
    -L/c/OpenSSL/lib -lcrypto
\end{minted}

\subsection{Cross-platform with CMake}
Create \texttt{CMakeLists.txt}:
\begin{minted}{cmake}
cmake_minimum_required(VERSION 3.10)
project(OpenSSL_Examples)

find_package(OpenSSL REQUIRED)

add_executable(rsa_example rsa_example.c)
target_link_libraries(rsa_example OpenSSL::Crypto)

add_executable(ecc_example ecc_example.c)
target_link_libraries(ecc_example OpenSSL::Crypto)
\end{minted}

Далі власне build:
\begin{minted}{bash}
mkdir build && cd build
cmake ..
cmake --build .
\end{minted}

\section{Additional Resources}

\subsection{Official Documentation}
\begin{itemize}
    \item OpenSSL Manual Pages: \url{https://www.openssl.org/docs/}
    \item OpenSSL Wiki: \url{https://wiki.openssl.org/}
    \item OpenSSL GitHub: \url{https://github.com/openssl/openssl}
\end{itemize}

\subsection{Standards Documents}
\begin{itemize}
    \item NIST SP 800-90A: DRBG Specifications
    \item FIPS 186-4: Digital Signature Standard
    \item RFC 8017: PKCS \#1 RSA Cryptography Specifications
    \item RFC 5639: ECC Brainpool Standard Curves
\end{itemize}
